---
title: Thermo Fisher siSilencer Select hEpigenetics/NucEnvelope siRNA Library Reshape
  and cellHTS2 analysis
author: "Gianluca Pegoraro"
date: "Jan 17, 2016"
output:
  html_document: default
  html_notebook: default
---
### Introduction
This script is used to analyze siRNA screen data obtained with High-Content Image analysis. In particular, the siRNA library used is the ThermoFisher Silencer Select hEpigenetics and hNuclear Envelope library. The library contains 3 oligo siRNA sequences per gene against 521 and 346 genes, respectively, involved in chromatin regulation and in the nuclear enevelope. 
The library was originally received dried in 96 well plates at 0.25 nM concentration. It was resuspended in 50 ul ddH20 (5 uM final), frozen and then thawed to increase oligo siRNA solubility. Column 12 of the 96-well plates was left empty on purpose.  The resuspended libraries (18 + 12 plates total), were then trasnferred and compressed into 384-well format to obtain 5 + 3 Mother plates (Plate 4 and plate 5 of the hEpigenetics library are not full). For every mother plate, 3 Daughter plates were generated at a 400 nM final concentration. Columns 23 and 24 were originally left empty, and siRNA controls were added at a later stage. For each Daughter plate, 3 Imaging assay ready plates were generated by spotting 2 ul of siRNA oligo at the bottom of the plate. All these liquid handling operations were performed using a PerkinElmer Janus instrument, which output all the liquid handling operations logs as text files. 
Imaging Assay plates were dried, frozen and then used in reverse transfection experiments. For reverese transfectio, plates were thawed, spinned and 20 ul of Optimem + 0.05 ul/well of RNAiMax were added to the plates and incubated for 30'. Then 20 ul of cells were added on top of the siRNA/RNAiMax mix and incubated for 72 hrs. 
Fixed and stained plates were imaged on an Opera QEHS microscope using a 40X water immersion objectives. Images were analyzed in Columbus 2.6, and image analysis results were exported as tab delimited .txt files. 
The script reads the Janus logs files, the Columbus image analysis results and generates all the necessary .txt files for the analysis of the siRNA screen results in `cellHTS2`. In addition, it also runs the `cellHTS2` analysis and output an html report. 

### Load packages.
```{r}
library(plyr)
library(ggplot2)
library(stringr)
library(knitr)
library(data.table)
library(cellHTS2)
library(ggthemes)
```

Choose a Columbus image analysis result variable that needs to be analized in `cellHTS2`. This might change from analysis to analysis. The Janus and Columbus files should be in dedicated Janus. The chunk below assigns the Columbus variable chosen for analysis and sets the `cellHTS2` input and output directories names accordingly . 
```{r measSelection}
meas_select <- quote(`Nuclei Selected - Number of Objects`)

Janus_output_dir <- "Janus_output"

HTS2_input_dir <- paste("cellHTS2_input", 
                        as.character(meas_select), 
                        sep = "_")
HTS2_output_dir <- paste("cellHTS2_output", 
                         as.character(meas_select), 
                         sep = "_")
```

```{r, include=FALSE, warning=FALSE}
opts_chunk$set(
    fig.path = paste0(HTS2_output_dir, "/"),
    cache = FALSE,
    dev = c("png"),
    fig.width = 15,
    fig.height = 7,
    message = FALSE,
    warning = FALSE
    )
```

```{r setThemeandPalette, include='false'}
theme_set(theme_minimal())
```

Generate the `r HTS2_input_dir` and `HTS2_output_dir` directories for the cellHTS2 input and output files, respectively, to be created by this script. In addition, create an empty template for the `cellHTS2` description file in the same directory. This file contains information about the experiment. Fill it in in a text editor before continuing. **Without this file cellHTS2 won't run**. 
```{r makeDir}
if(!dir.exists(HTS2_input_dir)){
dir.create(HTS2_input_dir)
}

if(!dir.exists(HTS2_output_dir)){
dir.create(HTS2_output_dir)
}

if(!file.exists(paste0(HTS2_input_dir,"/Description.txt"))) { 
    templateDescriptionFile(filename = "Description.txt", path = HTS2_input_dir)
}
```

### Read the siRNA layout from Thermo, the Janus reformatting logs data and the Columbus image analysis results
Read the siRNA layout information provided by ThermoFisher and select only relevant columns. The files should be in a directory named `Janus Output`. 
```{r geneListRead}

dt_nuc <- fread(paste0(Janus_output_dir, "/AMO20JUZ-Sil Sel NucEnvelope siRNA Lib-96 well-Total.txt")) # Pattern for Nuc Envelope Thermo Gene list file
dt_ep <- fread(paste0(Janus_output_dir, "/A30085-AMO20K2X-Sil Sel Hm Epigenetics siRNA Lib-96 well-Total.txt")) # Pattern for Epigenetics Thermo Gene list file

dt_gl <- rbindlist(list(dt_nuc, dt_ep))

setnames(dt_gl, c("Location (Row-Col)", "Plate ID"), c("Ambion_well", "Ambion_barcode"))

names_filter <- quote(list(`Lot Number`, 
                           Ambion_barcode, 
                           `Plate Name`, 
                           Ambion_well, 
                           Row, 
                           Col, 
                           `RefSeq Accession Number`, 
                           `Gene Symbol`, 
                           `Full Gene Name`, 
                           `Gene ID`, 
                           `siRNA ID`, 
                           `Exon(s) Targeted`, 
                           `Sense siRNA Sequence`, 
                           `Antisense siRNA Sequence`, Validated))

dt_gl_filter <- dt_gl[!(`Gene ID` == ""), eval(names_filter)]

dt_gl_filter
```

Set RegEx patterns for directory searches for logs file data and spot data on a per protocol step basis.
```{r regexFilename}
pat_r <- "Resuspension_Source_Plates_\\d*\\.csv$"# Pattern for Janus Resuspension Log files
pat_c <- "Compression_\\d*\\.csv$"# Pattern for Janus Compression Log files
pat_d <- "Daughter_Plates_\\d*\\.csv$"# Pattern for Janus Compression Log files
pat_s <- "Image_Plates_\\d*\\.csv$"# Pattern for Janus Spotting Log files
pat_ac <- "Add_siRNA_Controls_\\d*\\.csv$"# Pattern for Janus add Controls step log files
pat_col <- "result\\.1\\.txt"# Pattern for Columbus results files
```

Create a list of the RegEx patterns set in the previous chunk. **Important:** the list names will be carried over all the next steps!!!

* r = Janus Resuspension data
* c = Janus Compression data
* d = Janus Compression data
* s = Janus Spotting data
* ac = Janus add Controls data
* col = Columbus data

```{r patList, results = 'hide'}
pat_list <- list(r = pat_r, c= pat_c, d = pat_d, s = pat_s, ac = pat_ac, col = pat_col)

pat_list
```

Recursively search the working directory and its subdirectories for files whose name includes the RegEx patterns defined two chunks above. The `path_list` functon outputs absolute file names. `path_list` is a list containing all the filenames on a per Janus step basis.
```{r directorySearch, results='hide'}
list_files <- function(x){
  dir(pattern = x, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
}

path_list <- llply(pat_list, list_files) 

path_list
```

Extract file names from absolut path and set them as list element names. 
```{r trimNames, results='hide'}
trim_names <- function(x){
  names(x) <- basename(x) # This assigns the filename to the file that it is read
  y <- x ## This is necessary because of scoping issues
}

path_list <- llply(path_list, trim_names) 
```

Recursively read and merge object level data files as data.frames. Rows are labeled with relative filenames (The `.id` variable). This and the previous chunks are slightly modified tricks adopted from H. Wickam ["Tidy Data" paper](http://vita.had.co.nz/papers/tidy-data.pdf).
```{r readMerge, results='hide', warning=F}
read_merge <- function(x){
  dt <-as.data.table(ldply(x, fread, integer64 = "character")) 
}

dt_list <- llply(path_list, read_merge)
```

Separate Columbus data from the other classes of data. 
```{r separateColumbusData}
dt_col <- dt_list$col

dt_list <- dt_list[1:5]

dt_col
```

### Janus Files Cleaning
Eliminate the mixing steps, i.e. the steps where the source plate barcode and the destination plate barcodes are the same.
```{r eliminateMix}
eliminate_mix <- function(dt){
        dt <- dt[!(Rack == SrcRack),]
}

dt_list <- llply(dt_list, eliminate_mix)
```

Separate the remaining data tables.
```{r deleteDtList, results='asis'}
dt_r <- dt_list$r
dt_c <- dt_list$c
dt_d <- dt_list$d
dt_s <- dt_list$s
dt_ac <- dt_list$ac

rm(dt_list)
```

Rename `Rack`, `SrcRack`, `Well` and `SrcWell` according to the Janus protocol. 
```{r changeRackVariables}
setnames(dt_c, c("SrcRack", "SrcWell", "Rack", "Well"), 
               c("Ambion_barcode", "Ambion_well", "Mother_barcode", "Mother_well"))

setnames(dt_d, c("SrcRack", "SrcWell", "Rack", "Well"), 
               c("Mother_barcode", "Mother_well", "Daughter_barcode", "Daughter_well"))

setnames(dt_s, c("SrcRack", "SrcWell", "Rack", "Well"), 
               c("Daughter_barcode", "Daughter_well", "Assay_barcode", "Assay_well"))

dt_c
dt_d
dt_s
```

Eliminate the `Q1_001` string from some of the Ambion barcodes.
```{r barcodeRelabel}
dt_c[, Ambion_barcode := str_replace(Ambion_barcode, ".*(CPF[0-9, A-Z]{5})", "\\1")]
```

Assign a plate number to the Mother plates. For now this is a manual operation. The hEpigenetics library corresponds to plates 1-5, whereas the hNucEnvelope library corresponds to plates 6 to 8. 
```{r runingNumber}
run_number <- data.table(Mother_barcode = c("HT00003", 
                                            "HT00004", 
                                            "HT00005", 
                                            "HT00006", 
                                            "HT00007",
                                            "HT00023",
                                            "HT00024",
                                            "HT00025"),
                         Plate_Number = 1:8)

setkey(run_number, Mother_barcode)
setkey(dt_c, Mother_barcode)

dt_c <- dt_c[run_number]

dt_c
```

Eliminate the water addition steps to the Daughter plates.
```{r filterDaughters}
dt_d <- dt_d[!(Mother_barcode == "Reservior_001"),]
```

Eliminate the `Daughter1_001` string from some of the Daughter barcodes in the Daughter plates.
```{r barcodeRelabel2}
dt_d[, Daughter_barcode := str_replace(Daughter_barcode, ".*(HT[0-9]{5})", "\\1")]
```

Join well annotations from the Thernmo FISHER table with the logs obtained from the Compression step (Reformatting from 96- to 384-well format).
```{r joinLevel1}
setkey(dt_gl_filter, Ambion_barcode, Ambion_well)
setkey(dt_c, Ambion_barcode, Ambion_well)

names1 <- quote(list(Plate_Number, 
                     Mother_barcode, 
                     Mother_well, 
                     `Plate Name`, 
                     Ambion_barcode, 
                     Ambion_well, 
                     Row, 
                     Col, 
                     `RefSeq Accession Number`, 
                     `Gene Symbol`, 
                     `Full Gene Name`, 
                     `Gene ID`, 
                     `siRNA ID`, 
                     `Exon(s) Targeted`, 
                     `Sense siRNA Sequence`, 
                     `Antisense siRNA Sequence`, 
                     Validated))

join1 <- dt_gl_filter[dt_c, eval(names1), nomatch = 0]

 
dt_plate_c <- join1[, .SD[1, .(Ambion_barcode, Mother_barcode)],
                    by = .(Ambion_barcode, Mother_barcode)]

dt_plate_c

join1
```

Join the resulting table (`join1`) with the logs from the stamping plates step (Generation of the diluted daughter plates).
```{r joinLevel2}
setkey(join1, Mother_barcode, Mother_well)
setkey(dt_d, Mother_barcode, Mother_well)

names2 <- quote(list(Plate_Number, 
                     Daughter_barcode, 
                     Daughter_well, 
                     Mother_barcode, 
                     Mother_well, 
                     `Plate Name`, 
                     Ambion_barcode, 
                     Ambion_well, 
                     Row, 
                     Col, 
                     `RefSeq Accession Number`, 
                     `Gene Symbol`, 
                     `Full Gene Name`, 
                     `Gene ID`, 
                     `siRNA ID`, 
                     `Exon(s) Targeted`, 
                     `Sense siRNA Sequence`, 
                     `Antisense siRNA Sequence`, 
                     Validated))

join2 <- dt_d[join1, eval(names2), nomatch = 0]

join2
```

Join the resulting table (`join2`) with the logs from the spotting plates step (Generation of the assay-ready imaging plates).
```{r joinLevel3}
setkey(join2, Daughter_barcode, Daughter_well)
setkey(dt_s, Daughter_barcode, Daughter_well)

names3 <- quote(list(Plate_Number,
                     Assay_barcode, Assay_well, 
                     Daughter_barcode, 
                     Daughter_well, 
                     Mother_barcode, 
                     Mother_well, 
                     `Plate Name`, 
                     Ambion_barcode, 
                     Ambion_well, 
                     Row, 
                     Col, 
                     `RefSeq Accession Number`, 
                     `Gene Symbol`, 
                     `Full Gene Name`, 
                     `Gene ID`, 
                     `siRNA ID`, 
                     `Exon(s) Targeted`, 
                     `Sense siRNA Sequence`, 
                     `Antisense siRNA Sequence`, 
                      Validated))

join3 <- dt_s[join2, eval(names3), nomatch = 0]

join3
```

### Plot the layouts
```{r glPlot, echo = FALSE, fig.height=12, fig.width=15}
gl_plot <- ggplot(dt_gl, aes(x = Col, y = Row, label = `Gene ID`))
gl_plot + geom_text(size = 1.5) +
            facet_wrap( ~ Ambion_barcode) +
            scale_x_continuous(breaks = 1:12) +
            ylim(LETTERS[8:1]) +
            ggtitle("Ambion hEpi Library 96-well Layout")
```

```{r cPlot, echo = FALSE, fig.height=12, fig.width=15}
join1_2 <- join1[, `:=` (Mother_row = str_extract(Mother_well, "[A-Z]"),
                      Mother_col = as.numeric(str_extract(Mother_well, "[0-9]+")))]

c2_plot <- ggplot(join1_2, aes(x = Mother_col, y = Mother_row, label = `Gene ID`))
c2_plot + geom_text(size = 1.5) +
            facet_wrap( ~ Mother_barcode) +
            scale_x_continuous(breaks = 1:24) +
            ylim(LETTERS[16:1]) +
            ggtitle("Ambion hEpi Compressed Library 384-well Layout")
```

### Generate gene annotations file for cellHTS2
Make the annotation file for `cellHTS2`, name it `Annotation.txt` and save it to the in the `r HTS2_input_dir` directory.
```{r}
dt_annotation <- join1[, list(Plate_Number, Mother_well, `Gene ID`, `Gene Symbol`, `siRNA ID`)]

# Rename variables according to cellHTS2 specifications
setnames(dt_annotation, c("Plate_Number", "Mother_well", "Gene ID", "Gene Symbol", "siRNA ID"),
                        c("Plate", "Well", "GeneID", "GeneSymbol", "siRNAID"))

# Change Well string according to cellHTS2 specifications
dt_annotation[, Well := sprintf("%s%02d", 
                                str_extract(Well, "\\w"), 
                                as.numeric(str_extract(Well, "\\d+")))][order(Plate, Well)]

write.table(dt_annotation, 
            file = paste0(HTS2_input_dir, "/Annotation.txt"), 
            quote = FALSE, 
            sep = "\t", 
            na = "NA", 
            row.names = FALSE, 
            col.names = TRUE)
```

### Generate configuration file for cellHTS2
Make the configuration file `Plateconf.txt` for cellHTS2 according to the documentation specifications:

> The software expects this to be a rectangular table in a tabulator delimited text file, with mandatory columns Plate, Well, Content, plus two additional header lines that give the total number of wells and plates (see Table ?? for an example). The content of this file (except the two header lines) are stored in slot plateConf of x.
As the name suggests, the Content column provides the content of each well in the plate (here referred to as the well annotation). Mainly, this annotation falls into four categories: empty wells, wells targeting genes of interest, control wells, and wells containing other things that do not fit in the previous categories. The first two types of wells should be indicated in the Content column of the plate configuration file by empty and sample, respectively, while the last type of wells should be indicated by other. The designation for the control wells in the Content column is more flexible. By default, the software expects them to be indicated by pos (for positive controls), or neg (for negative controls). However, other names are allowed, given that they are specified by the user whenever necessary (for example, when calling the writeReport function). This versatility for the control wells’ annotation is justified by the fact that, sometimes, multiple positive and/or negative controls can be employed in a given screen, making it useful to give different names to the distinct controls in the Content column. More- over, this versatility might be required in multi-channel screens for which we frequently have reporter-specific controls.
The Well column contains the name of each well of the plate in alphanu- meric format (in this case, A01 to P24), while column Plate gives the plate number (1, 2, ...). These two columns are also allowed to contain regular expressions. In the plate configuration file, each well and plate should be covered by a rule, and in case of multiple definitions only the last one is considered. For example, in the file shown in Table ??, the rule specified by the first line after the column header indicates that all of the wells in each of the 57 assay plate contain “sample”. However, a following rule indicate that the content of wells A01, A02 and B01 and B02 differ from “sample”, containing other material (in this case, “other” and controls).
Note that the well annotations mentioned above are used by the software in the normalization, quality control, and gene selection calculations. Data from wells that are annotated as empty are ignored, i. e. they are set to NA.

The configuration file tells `cellHTS2` where the samples, controls and empty wells are on each plate. The first 8 lines of the file (Headers and controls positions) are hardcoded for now. The samples layout are is appended from the processed information obtained from the Janus logs.
```{r setConfiguration}
line1 <- "Wells: 384"
line2 <- "Plates: 8"
line3 <- "Plate\tWell\tContent"
line4 <- "*\t*\tempty"

odd_rows <- paste(LETTERS[seq(1, 16, by = 2)], collapse = ",")
even_rows <- paste(LETTERS[seq(2, 16, by = 2)], collapse = ",")

line5 <- paste0("*\t[", odd_rows, "]23\tneg") # siNT in Column 23 odd rows (A, C, ..., O)
line6 <- paste0("*\t[", even_rows, "]23\tsiKiller") # allSTAR killer in Column 23 even rows (B, D, ..., P)
line7 <- paste0("*\t[", odd_rows, "]24\tsiLMNB")  # siLMNB  killer in Column 24 odd rows (A, C, ..., O)
line8 <- paste0("*\t[", even_rows, "]24\tpos") # siSYNE2 in Column 24 even rows (B, D, ..., P)

header <-  c(line1, line2, line3, line4, line5, line6, line7, line8)

header

# Write header to file
conf <- file(paste0(HTS2_input_dir, "/Plateconf.txt"), "wr")
writeLines(header, conf)
close(conf)
```
The samples layout is appended from the processed information obtained from the Janus logs and is written out to the the `r HTS2_input_dir` directory.
```{r }
dt_config <- dt_annotation[, .(Plate = Plate,
                               Well = Well,
                               Content = "sample")]

write.table(dt_config, 
            paste0(HTS2_input_dir, "/Plateconf.txt"),
            append = T, # append
            quote = F,
            col.names = F,
            row.names = F,
            sep = "\t") 
```

### Generate the measurement files for cellHTS2
Generate a `Master_Barcode_List.txt` file and save it in the working directory (i.e. the same directory where the .Rmd file is). According to the `cellHTS2` specifications, the file should have these columns: `PlateName` (The plate barcode, as determined in the Janus log files, a string), `Plate` (The plate number in the library, a number), `Replicate` (Self explanatory, a number) and `Batch` (if the experiment or replicate was run in different batches, not necessary). This file contains the information on which plates have been analyzed, and on what the internal organization of the run is.
The `Master_Barcode_List.txt` file is used to generate the measurement files to be read by `cellHTS2`.
```{r}
master_plate <- fread("Master_Barcode_List.txt")

# Join the master plate information to the Columbus analysis results based on the plate barcode
setkey(master_plate, PlateName)
setkey(dt_col, PlateName)

dt_col <- dt_col[master_plate, nomatch = 0]

dt_col

# Reformat the well names according to cellHTS2 specifications
dt_col[, WellName := sprintf("%s%02d", 
                                str_extract(WellName, "\\w"), 
                                as.numeric(str_extract(WellName, "\\d+")))]
dt_col

# Extract the variable to analyze in cellHTS2
dt_col_minimal <- dt_col[, .(PlateName = PlateName,
                             Plate = Plate,
                             Well = WellName,
                             Value = eval(meas_select))]
dt_col_minimal
```

Write out the measurement (One per plate) files out for `cellHTS2` in the `r HTS2_input_dir` directory.
```{r}
dt_col_minimal[, write.table(.SD, 
                             file = paste0(HTS2_input_dir,
                                           "/",
                                           unique(PlateName),
                                           "_cellHTS2.txt"), 
                             sep = "\t", row.names = F, 
                             col.names = F, 
                             quote = F,
                             na = "NaN"), 
               by = .(PlateName)]
```

### Generate the platelist file for cellHTS2
Generate and writeout the `cellHTS2` Platelist.txt file in the `r HTS2_input_dir` directory. 
```{r}
dt_platelist <- dt_col[, .(Filename = paste0(unique(PlateName),
                                             "_cellHTS2.txt"),
                           Plate = unique(Plate),
                           Replicate = unique(Replicate),
                           Batch = unique(Batch)),
                       by = PlateName]

# Delete Platename column as per cellHTS2 Platelist.txt specs
dt_platelist[, PlateName := NULL]

write.table(dt_platelist, 
            paste0(HTS2_input_dir,  "/Platelist.txt"), 
            quote = F, 
            sep = "\t", 
            row.names = F, 
            col.names = T)
```

### cellHTS2 Analysis
Read the measurement files in the `r HTS2_input_dir` directory. 
```{r cellHTS2Import}
HTS2_Object <- readPlateList(filename = "Platelist.txt",
                      name = as.character(meas_select),
                      path = HTS2_input_dir)
```

Configure the cellHTS2 object. This operation adds the description of the experiment to the results and adds the gene annotations. 
```{r}
HTS2_Object <- configure(HTS2_Object,
                  descripFile = "Description.txt",
                  confFile = "Plateconf.txt",
                  path = HTS2_input_dir)

table(wellAnno(HTS2_Object))
```

Plot the plates layout. 
```{r, fig.height=12, fig.width=15}
configurationAsScreenPlot(HTS2_Object)
```

Normalize the plates. In this particular case, use the B-score normalization to reduce the impact of possible spatial artifacts on the plates. 
```{r}
HTS2_Object_n <- normalizePlates(HTS2_Object,
                         scale = "additive",
                         log = FALSE,
                         method = "Bscore",
                         varianceAdjust = "byPlate")
```

```{r}
HTS2_Object_sc <- scoreReplicates(HTS2_Object_n, sign = "+", method = "zscore")
```

Summarize the replicates. In this particular case the final Z-score is going to be the mean of the two replicates Z-scores. 
```{r}
HTS2_Object_sc <- summarizeReplicates(HTS2_Object_sc, summary = "mean")
```

Annotate the cellHTS2 object with gene names and siRNA id's. 
```{r}
HTS2_Object_sc <- annotate(HTS2_Object_sc, 
                   geneIDFile = "Annotation.txt",
                   path = HTS2_input_dir)
```

Save the cellHTS2 object as an `.rda` file in the appropriate results subfolder in case someone wants to inspect it and/or further process it. 
```{r}
save(HTS2_Object_sc, file = paste0(HTS2_output_dir, "/HTS2_Object_sc.rda"))
```

Output the screen results as an `index.html` file in the appropriate results subfolder. 
```{r}
setSettings(list(plateList = list(reproducibility = list(include = TRUE, map = TRUE),
                                  intensities = list(include = TRUE, map = TRUE)),
                 screenSummary = list(scores = list(range = c(-4, 8), map = TRUE))))

cellHTS2_report <- writeReport(raw = HTS2_Object, 
                               normalized = HTS2_Object_n, 
                               scored = HTS2_Object_sc, 
                               outdir = HTS2_output_dir,
                               force = TRUE,
                               mainScriptFile = "siSilencer_select_Ambion_cellHTS2_analysis.Rmd")

HTS2_results <- data.table(getTopTable(cellHTSlist = list("raw"=HTS2_Object, 
                                      "normalized"=HTS2_Object_n, 
                                      "scored"=HTS2_Object_sc), 
                     file = paste0(HTS2_output_dir, "/Results_table.txt")))
```

```{r}
HTS2_results_median <- HTS2_results[!(is.na(GeneID)),
                                    .(median_score = median(score)),
                                    by = .(GeneID,
                                           GeneSymbol)][order(median_score, decreasing = F)]

write.table(HTS2_results_median, 
            paste0(HTS2_output_dir, "/Results_median.txt"),
            col.names = T,
            row.names = F,
            quote = F,
            sep = "\t")
```

```{r rankedDots, fig.height=12, fig.width=15}
HTS2_results[, UID := factor(paste(plate, well, sep = "_"))]

HTS2_results[, UID := factor(UID, levels = UID[order(score)])]

ggplot(HTS2_results[!(wellAnno %in%  c("sikiller", "empty")),],
       aes(x = UID,
       y = score,
       color = wellAnno)) +
       scale_y_continuous(lim = c(-7.5, 5), breaks = seq(-7.5, 5, 2.5)) +
       geom_point(size = 1.5, alpha = 0.5) +
       scale_color_solarized() +
       scale_fill_solarized() +
       theme_solarized(light = F)
```

```{r densityControls, fig.height=12, fig.width=15}
ggplot(HTS2_results[!(wellAnno %in%  c("sikiller", "empty")), ],
       aes(
       x = score,
       y = ..density..,
       color = wellAnno,
       fill = wellAnno
       )) +
       geom_density(alpha = 0.3) +
       scale_x_continuous(lim = c(-7.5, 5), breaks = seq(-7.5, 5, 2.5)) +
       scale_color_solarized() +
       scale_fill_solarized() +
       theme_solarized(light = F) 
```

```{r dotsControls, fig.height=12, fig.width=15}
ggplot(HTS2_results[!(wellAnno %in%  c("sikiller", "empty")),],
       aes(x = normalized_r1_ch1,
       y = normalized_r2_ch1,
       color = wellAnno)) +
       scale_x_continuous(lim = c(-7.5, 5), breaks = seq(-7.5, 5, 2.5)) +
       scale_y_continuous(lim = c(-7.5, 5), breaks = seq(-7.5, 5, 2.5)) +
       geom_point(alpha = 0.3) +
       geom_smooth(method = "lm")

samples <- HTS2_results[wellAnno == "sample",]

samples[, cor.test(normalized_r1_ch1, normalized_r2_ch1, method = "spearman")]
```

Run the RSA analysis on the cellHTS2 object and save the results as `Results_table_RSA.txt`. **Important note:** the RSA analysis also includes `positive` and `negative` controls, whereas here we are saving to file only the `sample` wells. In addition also output a `Results_table_RSA_filter.txt` table which contains only genes for which at least 2 siRNA oligos give a phenotype 1.5 MAD's away from the `sample` population median. 
```{r}
HTS2_rsa <- data.table(rsa(HTS2_Object_sc, reverse = F))

HTS2_rsa <- HTS2_rsa[!(is.na(GeneID)),]

HTS2_rsa[, Plate := as.integer(Plate)]

setkey(HTS2_rsa, Plate, Well)
setkey(dt_annotation, Plate, Well)

HTS2_rsa <- HTS2_rsa[dt_annotation, nomatch = 0][order(RSARank)]

write.table(HTS2_rsa, 
            paste0(HTS2_output_dir, "/Results_table_RSA.txt"),
            col.names = T,
            row.names = F,
            quote = F,
            sep = "\t")

```

```{r}
HTS2_rsa[, Flag := Score < -1.5]

HTS2_rsa_flag <- HTS2_rsa[, .(Flag2 = (sum(Flag) >= 2)), by = GeneID]

setkey(HTS2_rsa, GeneID)
setkey(HTS2_rsa_flag, GeneID)

HTS2_rsa <- HTS2_rsa[HTS2_rsa_flag, nomatch = 0][order(RSARank)]

HTS2_rsa_thresholded <- HTS2_rsa[Flag2 == TRUE,]

write.table(HTS2_rsa_thresholded, 
            paste0(HTS2_output_dir, "/Results_table_RSA_filter.txt"),
            col.names = T,
            row.names = F,
            quote = F,
            sep = "\t")
```

Document the information about the analysis session
```{r sessionInfo, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```
